信息中心网:
    信息中心网只是一种思想, 其中数据不一定要"命名", 协议也不一定在网络层.

模拟器与工程软件的差异:
    对扩展性要求高, 可适当忽略安全性

AnnounceTable:
    announce的添加是有序的
    优点:灵活多变,特别适应于对扩展性要求高的软件结构
    缺点:Announce过于集中, 对于其中 announce 信号的了解全靠约定, 拼写出错不会提醒




    
模拟器结构：
    总线结构，附加Module监听和发布
    模拟器系统结构图：


设计与实现
    时间片的实现：
        离散事件模拟技术

    包的设计与实现：
        Name:
        Type:
        Nonce:
        Size: size 与 data 脱离
        *域可自由定制, 通常配合转发,匹配,储存,替换等策略使用

        签名，安全性等等

    节点的模拟：节点结构的设计，节点的主要工作内容
        FaceUnit：Face的定义
        AppUnit: 
        CSUnit：节点容量控制，匹配算法在此
        ReplaceUnit: 替换的实现在此
        InfoUnit: pit, fib 在此
        ForwardUnit：节点处理输入控制，转发策略实现在此，重传机制的实现
        
    信道的模拟：
        rate
        delay
        loss

    拓扑结构的配置：
        networkx：graph对图进行管理


模拟器Module：主要功能监听，记录，控制，展示，扩展等功能
    HubModule
    
    GUIModule
        Plugin: 针对GUI的扩展
    *NameMonitor
    *NodeMonitor
    *EdgeMonitor
    
    LogMonitor

    DBModule
    *StatisticModule
            
    GuideMonitor: 扩展功能

    
随着以信息为中心网络（Information-Centric Networking）[1]研究的深入，随之产生了以信息为中心网络在物联网环境下应用的需求，同时，也产生了对物联网环境下进行以信息为中心网络仿真实验的需求。然而，现有的模拟实验环境不能模拟异构的物联网设备在信息中心网络环境下的表现，因此不能很好的适应仿真实验的需求。

为此，本文在研究了常见的以信息为中心物联网环境下实验的实验内容，设计并实现了一个有针对性的模拟器。首先，模拟器能对节点的储存容量和处理包的效率上进行仿真，实现对物联网中节点异构性的模拟。其次，模拟器能对信道的速率，延迟，丢包率进行仿真，实现信道异构性的模拟。同时，模拟器也通过将以信息为中心网络中的操作，抽象成包的转发、包的储存、包的匹配、包的替换几个基本操作，并对这些操作进行仿真，来实现对以信息为中心网络的模拟。
本文具体内容如下：首先，阐述了国内外信息中心网模拟软件现状和不足，介绍了本模拟器的产生背景和要完成的设计目标。其次，介绍了模拟器的主要模块及其功能以及核心功能模块设计理念和实现方式。第三，通过实验例子演示了模拟器的使用方式，讲解了用户如何通过扩展模块的方式，实现对模拟器的扩展。最后，介绍了模拟器现有功能的不足和将来可以改进的方向。

On Content Diffusion Modelling in Information-Centric Networks

With the research of Information Centric Networking(ICN) go on, people were trying to apply this protocal under the Internet of Things(IoT). Researchers need a simulater which work on the ICN environment to help them finished thire experiments, but traditional network simulater can not support the heterogeneous IoT, which nodes and channel in network have very different property. This paper base on a lot of research papers and experiments, and trying to develop a customed simulater for these research. First of all, we find a solution to simulate node, it can deal with the node's content store and packet transfer, node and node could be custom by change this property. Then we also simulate channels, make each channel have different rate, delay, loss rate property.The simulate abstract the process of network infomation transport to basic operate of packet, such as packets forward, packets store, packets match, packets replace and so on. Simulate these operates can help us to develop simulater core.
This paper include these part: first 

Then 

As the network for the center with Information (Information - Centric Networking) [1] research thorough, centered on Information network has sprung up under the environment of Internet of things application demand, at the same time, also produced under the environment of Internet of things for the demand of the network simulation experiments for the center with Information.However, the existing simulation environment can not simulate the heterogeneous iot device in the center of the information under the network environment, so you can't meet the requirement of simulation very well.Is studied in this paper, common information centered iot environment experiment of experiment content, designs and realizes a targeted simulator.First of all, the simulator can storage and processing of the node package on the efficiency of simulation, the implementation of the simulation of the heterogeneity of nodes in the Internet of things.Second, the simulator to channel rate, delay, packet loss rate, simulation realization channel simulation of heterogeneity.At the same time, the simulator will be centered on information through the network to the operation, the abstract into the packet forwarding, storage, bales of matching, the replacement of several basic operations, and the simulation of these operations, to implement the simulation of centered on information network.
In this paper, the concrete content is as follows: first of all, this paper expounded the status of domestic and international information center network simulation software and the insufficiency, this paper describes the background of this simulator and to complete the design goal.Secondly, this paper introduces the main modules and functions of the simulator and the core concept of function module design and implementation way.Third, through the experiment example demonstrates the use of the simulator, explained how the user through the way of extension module, realize to the expansion of the simulator.Finally, this paper introduces the simulator, the shortage of the existing function and can improve the direction in the future.
    
    
    
本论文主要针对以信息为中心物联网模拟器的设计与实现过程进行介绍，介绍了模拟器的设计思路与实现细节，并介绍了模拟器的基本使用方法与实际应用。
本论文分为六章：
第一章主要介绍了以信息为中心物联网模拟器的技术背景，对比国内外相似模拟器功能与应用范围，之后对本模拟器要设计与实现中要研究的内容进行了说明。
第二章主要介绍了以信息为中心物联网相关概念，描述以信息为中心网络转发信息的机制与过程，展现了现有研究中主要关注的问题与实验内容。
第三章主要介绍了模拟器针对以信息为中心物联网实验的内容要解决的问题、模拟器需求的分析及概要设计。
第四章主要介绍了模拟器的设计与实现方式，描述了模拟器的软件结构与主要模块，还介绍了模拟器核心的实现方式以及采用此方式的优缺点，对于每个模块介绍了模块的功能与实现方式以及模块的适用范围。
第五章主要介绍了模拟的使用方式以及使用效果，通过一个例子展现如何创建实验使用的节点、信道及如何搭建实验网络。此章也介绍了图形界面组件与图表意义。
第六章是总结与展望，对模拟器现有功能进行总结，并针对现存的不足进行分析，提出未来模拟器可改进的方向。
    
    
 

随着网络基础设施的不断发展，以信息为中心的网络与传统的基于IP地址的传输模型相比，对通信模型进行了提升。以信息为中心的网络包含依照命名进行的内容索引方式、非基于原始服务器地址的通信方式及相应的应用层程序和传播信道四个部分组成，并依此实现网络内容的安全缓存与复制。因为以信息为中心的网络在复杂网络环境下有着较好的数据传播效率和鲁棒性，而物联网中存在大量异构且受限的网络设备，所以以信息为中心的网络适合作为物联网环境下的网络通信规范。
物联网的定义仍在争论，但基本可以认为物联网的主体是为全球提供信息和服务的数十亿异构的设备，这些设备功率强弱各异，可以是生活常用的也可以是生产中使用的，可以是真实的也可以使虚拟的。物联网通常使用基于IP地址的网络来实现相关传输机制，这个领域活跃着许多互联网工程小组(例如，6LoWPAN,ROLL,CoRE)，为此方面的研究取得了很大的进步。但基于IP网络的物联网解决方案仍然在大规模部署的情况下面临挑战。IP地址不能充当定位器和标识符，因此还要提供一个复杂的系统来解决移动网络、多播及设备性能受限情况下却要进行大量访问的问题。此外学界目前也正在探索如何将互联网系统转变为一种更有高效、更适合内容分发的系统。
以信息为中心网络的提出了一种全新的下一代互联网结构。与现有的以地址为中心的网络不同，以信息为中心网路中每一块信息片段都是独立、不可变且被命名的，应用层应用将直接对这些内容片段进行访问。这种革命性的模式也保障了内容数据的安全性，并能在网络中对数据进行缓存。这种特性使得以信息为中心的网络不仅能利用于互联网上的信息发布，而且更能支持多种物联网场景。事实上，以信息为中心的网络能适用于大部分的物联网应用场景，物联网本质上也是以信息为中心的，因为其访问目标是数据，而不考虑存储或产生数据的对象位置。例如，对道路交通环境检测的应用中并不需要知道提供信息的车辆网络地址。以信息为中心网络可以通过对数据进行命名的方式统一处理异构网络中产生的信息。与IP地址不同，这些内容的命名规则与生产者的网络位置无关，因此可以将数据缓存到更接近数据消费者的地方，这样可以减少数据获取的延迟以及网络负债，并能减少资源受限设备的被访问次数。例如一个传感器设备发送过一个数据，此数据将会被缓存到网络中，再次对该数据进行查询时将直接利用网络缓存而非再次访问传感器设备。




对于以信息为中心物理网的研究，有很多可以关注的要点，以下主要是将相关论文研究内容进行总结，梳理出常见的研究要点，这些要点将用于指导模拟器的需求分析与概要设计。

1、网络拓扑结构
物联网与普通网络一样也有经典的网络拓扑模型，如星形网络、环形网、无标度网络、全联通网络等，但物理网与普通网络不同之处在于，同样的网络拓扑结构下会由于物理网中节点异构性较大而造成网络性能差异性大。因此以信息为中心物理网的研究中可能会对不同网络拓扑结构进行比较研究，也可能对相同拓扑结构下不同的节点属性进行比较研究。

2、信息包结构
信息包用于承载请求信息以及相应数据，根据这些信息能对数据进行命名、指导包在网络中的转发或缓存、对数据真实性进行校验、对数据安全性进行保证等等。特别是对信息的命名方式直接决定了以信息为中心网络运行效果，例如设计一种命名协议能使得对使用频率高的内容命名较短、而使用频率低的内容命名相对较长可以减少对信息名字索引平均处理时间。研究如何设计包的结构与编码方式，使得包在能在完成以上功能同时占用更小的资源也是一信息为中心物联网的研究要点。


3、信息的产生与对信息请求的产生
物联网中通常为传感器节点产生数据，数据处理中心收集数据。产生数据或请求的节点数量可能服从某种概率分布如服从均匀分布或泊松分布；产生节点的位置也可能符合某种分布模型，如均匀散布在网络中或与中心节点的距离呈Zipf分布。因此以信息为中心物理网的研究中可能对不同的信息产生模型进行比较研究。

4、网络的转发策略
网络中对数据进行路由与转发的策略是影响网络性能的重要因素，转发策略指导请求数据包如何转发到数据缓存节点以及数据包如何转发到请求节点。转发策略的研究中还涉及到信息表的建立与使用问题，例如现有以信息为中心网络节点中利用等待兴趣表对请求包到来接口进行记录，在数据包到来时能指导数据包转发到相应的请求节点；网络节点中利用转发信息库对节点接口进行管理，在兴趣包到来时能指导兴趣包转发向有更高概率获取相应数据的接口。通常请求兴趣表或转发信息库所能占用的内存越大、结构越复杂，节点能实现的转发效果越好，但是因此对节点性能的要求也越高，转发策略的研究中会对此类问题进行详尽的讨论与实验。由于物联网的异构性，常常在一个网络的不同硬件中运行着不同的转发策略。例如功率受限的传感器节点对数据可能采取更为保守的转发方式，手段有延长重传机制的间隔时间、一次只向一个节点转发信息、信号差时不再传输数据等；而性能较强的节点可能采取更激进的转发策略以降低网络延迟。因此转发策略是以信息为中心的网络研究重点。

5、网络的缓存策略
以信息为中心网络的最大特点就是网络中会对内容数据进行缓存，因此也产生了各式各样的缓存策略。比较常见的缓存策略为处处留下缓存（Leave Copy Every），此种方案实现策略简单但是可能会给节点带来较大的性能开销，例如一个数据从数据源经过了5跳到达请求源，此时会在5个节点中留下数据拷贝，如果全网平均请求转发跳数为5跳则在网络中进行缓存与拷贝的数据量为全网数据转发量的5倍。然而通常一条路径中只有少数节点的缓存会被利用，而多数缓存在被替换掉之前没有被利用过。针对这一问题，研究者们提出了多种解决方案，例如依照概率留下缓存（Leave Copy Probable）策略，每当数据到达一个节点，只有一定的概率被节点进行缓存，如果缓存概率为20%则一个5跳的数据转发路径留下缓存的期望数量则为1个，但是策略网络延迟可能比处处缓存策略要大，因此如何对此策略进行改进也是研究的要点，当然还有更多思路不同缓存策略被提出。

6、网络替换策略
有信息为中心的网络中节点缓存容量有限，因此当新的缓存到达节点时存在旧缓存数据的替换问题，替换策略可以各式各样，常见的有先来先替换（FIFO）策略或最近最少使用（LRU）策略。依照网络的特性还会有很多有针对性的替换策略，例如一个信息源实时产生并更新数据的网络，获取数据的新鲜程度越高越好，则替换缓存策略会采用后产生的数据替换先产生的数据，而不在适用于先来先替换策略或最近最少使用策略了。比较不同的替换策略是以信息为中心物联网研究的要点。

7、其他可能的研究要点
在以信息为中心网络中，通常为请求源发起请求数据源响应请求，并在数据转发至请求源的过程中留下缓存。但是有研究对此种机制进行了扩展，数据源也可以在没有请求的情况下主动向周围节点推送数据，通常一个未经请求的数据包会被视为对网络的资源的浪费甚至被视为恶意攻击行为而直接抛弃，但如果要实现数据的主动推送策略，就要对现有的以信息为中心网络的机制进行扩展，如果实现对数据的安全推送也就成为一个研究点。再扩展出去，如果网络中允许对未经请求的数据包进行推送，也有可能会出现一个节点繁忙利用周围空闲节点对高频数据进行缓存的策略，这种策略是否能够工作与效率如何也可以加以研究和讨论。
以信息为中心的物联网也同样存在着流量控制问题，洪泛攻击问题等种种互联网中常见问题。互联网中解决这些问题的方式是否能照搬到物联网中，以地址为中心网络的控制方式是否能指导以信息为中心网络的控制也是研究的要点。








    
对于如以信息为中心网络这一类在研究中的网络，因为网络协议变化较大，实现其模拟器要特别注重扩展性，能根据实验和研究的需求快速而便捷的更改和添加功能和模块。因此本模拟器设计时决定采用一个内核实现核心功能，再通过挂载模块的方式进行扩展，来搭建出一个完整模拟器。因此只需要搭配不同的模块则可定制所需的模拟器。例如在进行新功能、新协议调试时，通常希望了解每个节点和信道的具体信息或每种信息在网络中的具体位置等细节问题，对仿真速度上要求低，甚至是手动进行单步调试，这时就可以挂载图形化模块（GUIModule）以展示网络信息，挂载日志模块（LogModule）以追踪模拟转发过程。而在验证性功能、新协议是否可靠，要进行大规模实验时，对仿真速度要求较高，这时不需要图形化展示，也不需要日志的追踪，只是在实验结束后收集实验结果和对结果进行统计分析，这种情况，不再挂载图形化模块（GUIModule）和日志模块（LogModule），而改为挂载数据库模块（DBModule）和统计模块（StatisticModule）即可。

图 模拟器系统结构图

在模拟器中，模块间可能相互依赖、相互提供服务，因此带来了模块间的通信问题。由于模块的搭配变化性大，模块间的依赖结构会变得不固定而多变，在此为了追求高扩展性，传统软件结构常用的分层结构（如分为数据库层，逻辑实现层，输入输出层），而采用单一总线结构。模块挂载到总线上后，模块的任何消息都会发布通告（Announce）到总线上，其他所有模块都可以监听到，且模块提供的任何应用编程接口（API）都可被其他模块调用甚至修改。采用这种设计的优点是使得软件结构变得简单，扩展性更强，但缺点是降低了软件的安全性。在实现时，总线采用字典结构来储存Announce和API，模块通过写入键值对的方式来添加自己的Announce和API到总线上，再通过查询键值对的方式来监听其他模块的Announce和调用其他模块的API。因此如果有两个模块的Announce或API命名相同，即在总线中的键名相同，则后写入的模块会覆盖掉前一个模块的键值对，这种覆盖不会引起警告或错误，由此造成难以察觉的Bug。在实现时，只能通过对Announce和API的命名规范来保证这种冲突不会发生。总体而言，选择这种软件结构是利大于弊的。
以下，将介绍模拟器的内核和现已实现的主要模块。



模拟器核心功能的设计与实现：
1 模拟时间片的设计与实现
本模拟器利用离散事件模拟技术模拟时间片的推进，现实中的时间是连续的，理论上不存在同时发生的事件。而在模拟中，会对时间进行分割，分成单独的时间片，在同一时间片中发生的事件，将会被简化为在同一时间点发生的事件。对离散时间点上事件的仿真技术即为离散事件模拟技术，其实现步骤如下：首先确定会产生事件的实体及其属性，所有实体的属性统一构成系统的状态。模拟器中的实体主要有模拟器节点和传输数据的信道，模拟器节点的属性包括节点处理能力、缓存容量大小等，而信道的属性包括传输速率、延迟、丢包率等。其次，确定会导致系统状态变化的事件，并针对事件进行模拟。模拟器中会导致系统状态变化的行为有节点对包（Packet）进行接收、匹配、缓存、发送等，这些行为就是模拟主要要进行模拟的事件。最后，确定模拟时间的推进方法，如果顺序的考察每一个时间点是否出现事件，称为固定时间距离法；每次推移的长度是以下一事件发生时间点为依据的方法，称为可变时距法。固定时间点实现方式简单，适用于大量事件的模拟，可变时距法实现复杂，但适用于稀疏事件的模拟。因为本模拟器常常需要对大规模网络进行仿真，模拟的事件往往数量大、密度高，因此将采用固定时间距离法。（图 离散事件转化图）
在模拟器实现中，一个事件用一个事件对象（Event）进行表示，其中记录了事件要执行的回调函数和函数的参数，执行一个事件即以事件对象记录的参数调用该对象中的回调函数。一旦一个事件对象被执行，其中记录的信息也将被清空，这点有助于使用者判断一个事件是否已经被执行。未被执行的事件也可同通过调用事件对象的清空函数（Event.clear）来取消事件的执行。
所有的事件都采用一个单例的时钟对象（Clock）来进行储存和管理，时钟对象储存事件的数据结构为字典，字典键为代表时刻值，字典值为有序的事件序列。第N刻发生的事件将会被添加到键为N的事件序列中，等待被执行。当时间片推进到一个键所代表的时刻时，则该键对应的事件序列将会被按序执行。特别的，在第N刻执行的事件里，仍然可以向时钟对象中追加第N刻要执行的事件。一旦第N刻的所有事件执行完成，就可以认为对第N刻的模拟已经结束，时间片会被推进到第N+1刻。在添加事件时有要注意，添加事件的时刻值必须是非负整数。（图 时钟结构图）
模拟器还提供了定时器（Timer）来帮助使用者管理事件，定时器能实现在给定延迟后执行一个事件的功能，还能实现将事件进行重新定时的功能。
 
 
2 包的设计与实现
包（Packet）是以信息为中心网络中信息传输的基本单位。模拟器中的包用一个包对象来实现，为了实现对以信息中心网络的基本功能的模拟，现有的包结构主要包含以下属性。
2.1 名字域
在以信息为中心的网络中，名字（Name）是信息的标识，一个包有且只有一个名字域（Packet.name），用于该包所属的名字值。名字以分段进行表示，每段都为字符串，段间以"/"符号作为分割，如"Bupt/mp4/part1"是一个名字格式，分为三个段："Bupt"、"mp4"、"part1"。名字的顺序依照分段按照字典序进行排序，如"Bupt/mp4"<"Bupt/mp4/part1"<"Bupt/mp4/part2"。
在模拟器的实现中，名字对象采用分段的方式来储存名字，数据结构为字符串序列。首先将字符串形式的名字以'/'字符为界，切割为多个分段，再将每个分段按序储存，如图（图Name对象储存图）。为了简化模拟器的实现，模拟器中的名字不能包含转义字符，即'/'字符一定会被当做分段符号处理，名字"Bupt//mp4"将会被解析为3段："Bupt"、""、"mp4"。
2.2 类型域
在以信息为中心的网络中，包主要被分为两种类型，一类用于表示对信息的请求，称为兴趣包；另一类用于表示对请求信息的回应，称为数据包。具体而言，节点通过发送一个含有某个名字的兴趣包表示对该名字对应数据的请求，如发送名为"Bupt/mp4/part1"的兴趣包表示希望从网络中获取名为"Bupt"的mp4格式视频数据的第一部分；而收到同名的数据包表示对该兴趣包的回应，如收到名为"Bupt/mp4/part1"的数据包时，数据包的载荷即为所请求的数据。注意，上述例子只用于说明包类型的意义，不代表mp4文件一定或必须依照此方式命名，对于信息的命名规则，也不是本文要讨论的内容。
在模拟器的实现中，包的类型域（Packet.type）用一个字符串来表示，值为"Interest"表示这是一个兴趣包，值为"Data"表示这是一个数据包。包的类型不限制与以上两种，用户可以根据实验需求自定义和扩展包的类型，只需要对包的类型域赋值即可，采用这种设计的优点是为用户扩展提供便利，因为在对相关实验需求的调查中发现，有的实验具在兴趣包和数据包之外，还有请求响应包，请求驳回包等多种类型，因此应该用变量类型而非枚举类型来表示包类型。缺点在于，包的类型过多，可能会增加转发算法设计和实现的复杂度。
2.3 尺寸域
模拟器中的包尺寸属性（Packet.size）与荷载分离，现实网络中的包尺寸定义是包经序列化后序列所占字节数量，通常为包头字节数加荷载字节数。但在模拟器中，尺寸与包占用内存大小无关，例如一个尺寸为1000的包，不一定有1000个字节的荷载，反之，一个尺寸为1的包却有可能携带尺寸为1000的荷载。采用这种设计的的优点是通过修改尺寸属性就能模拟不同尺寸的包，而不用去真正占用相应空间的内存，缺点是与现实网络中包尺寸的意义有所差异，丢失一些模拟真实性。
在模拟器实现中，包的尺寸用一个整形来表示，没有具体单位。根据不同的实验，可以理解为不同的单位。
2.4 随机域
包的随机域（Packet.nonce）来源于NDN协议中包的随机域，该属性是一个随机数，主要用于网络中循环包的检测。具体实现为32位无符号整形随机值。
如果一个节点接收到两个相同名字、相同类型、相同尺寸的兴趣包，如何知道这两个包是对同一信息的两个请求，还是由于网络中环路造成了同一请求的分为两次抵达呢？这里就需要比较两个包的随机域是否相同，如果不同则是两个同名的请求，否则判断为是同一个包的两次抵达。当然，这里会存在随机域冲突的问题，但是概率较低，而且造成的误判也可由重传机制进行纠正。
要注意区分名字域和随机域的意义，名字标识的是以信息为中心网络中的信息，相同名字代表相同信息，而随机域用于标识的是包。包的名字域、类型域、尺寸域、随机域构成的四元组，称为包的头部（Packet.head），用于唯一的标识网络中的一个包。

用户可以通过添加和修改包对象的域，来定制实验所需要的包，这些域通常用于配合转发、匹配、储存、替换、校验等功能的实现，如命名数据网络会通过添加签名域和摘要域来对包的安全性和真实性进行检验。考虑数据域不是实现模拟以信息为中心网络的必要部分，所以也没有将数据域包含在包结构中。


3 模拟节点的设计与实现
在以信息为中心物联网中模拟器节点要实现的功能有信道的链接与断开、包的接受与发送、数据包的存储于替换、为匹配兴趣包的转发与信息记录等。也要能对节点的性能进行仿真，在此主要是对节点内容缓存（ContentStore）的容量和单位时间内处理包的数量即处理速率两个维度进行仿真。例如现实网络中的服务器运算速度快、内存容量大，在模拟器中就抽象为高内容缓存和高处理速率的节点；现实网络中传感器节点功率低，且一般不作网络路由设备，所以可以抽象为运算速度低，无内容缓存的节点；现实网络中的路由器可能运算速度高却内存小，也可以通过配置节点的内容缓存容量数值和处理速率进行模拟。由于不同的模拟器节点可能拥有不同功能，所以采用了总线上挂载所需要单元（Unit）的设计模式，以下将分别介绍一个模拟器节点可能会用到的功能单元以及其设计和实现方式。
3.1 接口单元
接口单元（FaceUnit）负责节点的网络接口（Face）信息的管理，能实现接口信息的增删改查，接口单元用一个字典储存着接口信息，字典键被称为接口标识（FaceId），实现时通常采用目的节点的名称作为接口标识，字典值是一个接口对象（Face）。通常接口对象用于管理节点间的连接，接口对象中储存着连接当前节点与目的节点的信道（信道将在下一节进行介绍），也管理着一个节点是否被允许向目的节点发送数据和是否能从目的节点接收数据。但有一种接口除外，即应用层接口。应用层接口负责管理节点网络层与应用层间的连接，由应用层到来的包经由此接口到来，回应应用层的包经由此接口出去。
接口单元除了管理接口信息的功能，还内置了两个检查器，分别是循环包检查器（LoopChecker）以及重复包检查器（RepeatChecker）。由于网络中存在着环路，同一个包可能经过两条不同的路径到达一个节点两次，模拟器在接口单元利用循环包检查器进行检测，检测的方法为比较当前包的包头是否与之前到达过的包头重复，如果有重复则判定为循环包，接口单元以当前包作参数发布"loopPacket"通告，如果非循环包则以当前包作参数发布"inPacket"通告，表示节点接收到一个包，具体对包如何处理，将交由该通告的订阅者实现。在接口单元中，所有到来的包头部都会储存在循环包检查器中以实现对循环包的检查，而该信息的储存时间由参数nonce_life_time决定，nonce_life_time越大，接口单元能检测到的循环包的能力越强，但所占用的内存也会越多。设计循环包检查器在接口模块就将循环包进行区分，能减轻转发策略算法的实现负担。在实验实践中发现，由于转发策略的实现方式，有可能会造成一个节点在同一时间向同一接口提交多次发送请求，这种重复的请求并不具有实际意义，因为同时向同一接口发送同一个包多次是没有意义的，甚至可能会造成转发包的泛滥，因此基于实践经验，在接口单元中还实现了重复包检查器，重复包检测器的功能就是避免上述情况发生，在包从一个接口被发送前都会通过重复包检测器对接口标识、包名、包类型三元组进行检测，如果与记录表中的记录有重复则判定为重复包，发出以该包为参数发出"repeatePacket"通告，没有重复则为正常情况，以该包为参数发出"outPacket"通告，并经由相应接口对象发出到相应信道。由于重复包的检测仅限于当前时间片，所以重复包检查器总的记录生存时长为1个时间片。（图，接口单元处理包流程图）
3.2 应用层单元
应用层单元（AppUnit）用于实现节点应用层功能的模拟，现有的应用层单元功能如下，一、在单元安装入节点时在接口单元中建立应用层接口（因此应用层单元依赖于接口单元），应用层接口的接口标识由APP_LAYER_FACE_ID常量规定；二、提供名为"App.ask"的API，可由节点其他模块调用以对网络层下发一个兴趣包；三、在从网络层接收到一个包时以该包作为参数向节点信息总线上发布"respond"通告。用户可以通过重写该单元定制自己所需的应用层功能，如兴趣包的重传机制和超时机制等。
3.3 内容缓存单元
内容缓存单元（ContentStoreUnit）是信息为中心网络的重要组成部分，在节点中用于缓存信息。在内容缓存单元中，利用字典来实现缓存表，字典键为内容名字，字典值为对应数据包。内容缓存单元还实现了对内容缓存尺寸的限制和管理，内容缓存容量是所能缓存所有包尺寸值的和的最大值，如内容尺寸为1000则最多储存10个尺寸为100的数据包或100个尺寸为10的数据包等等。其他模块可以通过调用名为"CS.store"的API，实现向内容缓存单元储存一个包，其流程如下：首先内容缓存单元会检查自己是否能储存这个包，如果包尺寸大于自己的容量，返回False值；其次内容缓存单元会检测是否已经缓存过同名的数据包，如有缓存则不再储存新的同名数据包并返回False值；之后内容缓存单元检测剩余存储空间是否足够，如果不够将调用名为"Replace.replaceIter"的API函数获取一个名字序列，依照该序列替换自己的内容缓存，每替换一个包都会以被替换的包为参数发布"csEvict"通告，直到剩余空间能存放下新到来的数据包为止；最后将新包添加到自己的缓存表中并以该包发布"csStore"通告。其他模块可以通过调用名为"CS.match"的API在内容缓存单元中查询一个兴趣包对应的数据包，如果内容缓存中有与兴趣包同名的数据包，则返回该数据包并以该包为参数发布"csHit"通告，否则返回空值并以兴趣包为参数发布"csMiss"通告。（如，内容缓存流程图）
注意，在内容缓存单元的替换功能中，并没有具体实现如何生存缓存包的替换顺序，仅仅是调用一个接口函数获取该序列，具体的替换信息管理交由替换单元实现。现有的内容缓存单元对兴趣包的匹配只限于名字相同的匹配，并未提供更高级的筛选方式，如用户需要更精细的匹配操作，可以通过在转发函数中添加筛选操作或直接重写ContentStoreUnit.match实现。对于重复的数据包，当前内容缓存单元采用丢弃新到来的包而保留之前到来的包的做法，这种设计已经能实现模拟器所需的基本功能，且实现方式简单。如果使用者有不同的实现需求，也可以通过重写ContentStoreUnit.store实现。
3.4 替换信息单元
替换信息单元（ReplaceUnit）负责内容缓存单元的替换信息管理，替换信息单元监听总线上的"csStore"、"csEvict"、"csHit"、"csMiss"通告，并根据该通告记录相应信息，替换信息单元负责提供"Replace.replaceIter"的API实现，该API要返回一个名字序列，该序列用于指导内容缓存单元的缓存替换，因此替换信息单元与内容缓存单元是相互依赖的。模拟器中的替换信息单元提供三种替换模式：先来先替换(FIFO)、最近最少使用替换(LRU)、最近最不常使用替换(LFU)。单元中维护着一个信息表，表索引项为包名字，条目中记录着该名字的缓存创建时间（c_time）、最近访问时间（a_time）、访问次数（a_count）。当监听到"csStore"通告时，为信息表添加一条以该通告中携带的数据包名字为索引的信息记录，将其创建时间和最近访问时间设置为当前时间，访问次数设置为0。当监听到"csEvict"通告时，则删除对应名字的信息记录。当监听到"csHit"通告时，将对应名字的信息记录中最近访问时间设置为当前时间，访问次数增加1。当监听到"csMiss"通告时，意味着内容缓存单元中没有匹配到对应兴趣包，则替换信息单元不做任何变化。要实现先来先替换，将依照名字对应的创建时间从早到晚进行排序返回给内容缓存单元；要实现最近最少使用替换，将依照名字对应的最近访问时间从早到晚进行排序返回给内容缓存单元；要实现最近最不常使用替换，将依照名字对应的访问次数从小到大进行排序返回给内容缓存单元。
现有的替换信息单元记录了一个数据包对应的创建时间、最近访问时间、访问次数三项记录，因此能在运行中动态切换替换模式。使用者在实现自己的替换策略时，也应当实现能动态切换替换模式的功能。（图，替换信息表图）
3.5  转发信息单元
转发信息单元（InfoUnit）用于记录节点的转发信息，为转发策略的实现提供信息。在以信息为中心的网络中最常用一种转发信息表就是等待兴趣表（PIT）。等待兴趣表中记录了何种兴趣是从哪个接口进入，如果有匹配的数据包，将依照等待兴趣表中的信息将数据包转发出去。关于兴趣包和数据包的转发流程将在下一小结介绍，在此只说明转发信息单元的设计与实现方式。模拟器中实现的等待兴趣表结构为字典，字典键是兴趣包名字，字典值为本节点内接受过该名字兴趣包的接口标识集合。当转发信息单元监听到"inPacket"通告后，会判断通告中携带的包类型是否为兴趣包，如果是兴趣包则在包的名字对应的表项中添加该包到来的接口标识，当然有可能该接口之前接收过同名的兴趣包，所以表项中以及存在该接口标识的记录，这种情况是可接受的且不会引起任何警告或错误。当转发信息单元监听到"outPacket"通告后，会判断通告中的包类型是否为数据包，如果是数据包则在该包对应的表项中删除相应的接口标识，由于转发策略的实现不同，是可能存在向非等待兴趣接口发送数据包的情况的，所以如果表项中不存在该数据包发出接口对应的接口标识，也同样不会引起警告或错误。转发信息单元提供名为"Info.getPendIds"的API，其他模块可以通过调用该API获取一个名字对应的等待接口标识集合，例如转发策略可以此决定向哪个接口转发数据包。
在命名数据网中，转发信息单元除了等待兴趣表外，还提供了转发信息表（FIB），转发信息表和路由表类似，它是由转发策略构造的，短时间内应该保持一定的稳定性，为转发路由提供一定指导。但是在本模拟器实现中，并没有设计和实现转发信息表，理由有以下两点：第一，以信息为中心物联网拓扑结构比较简单，一个传感器节点能确定收到的兴趣包或数据包向哪一个端口转发而不需要查找转发信息表，因此只有少数中间节点的转发算法可能会利用到转发信息表。第二，由于转发策略的不同会导致要利用的转发信息表的格式不固定，所以模拟器将此功能留给实验使用者去实现。
3.6 转发策略单元
转发策略单元（ForwardUnit）是实现转发策略的核心模块，最基础的转发策略单元实现了以下几个功能：首先，该单元实现了节点对包处理速率的模拟，本单元监听节点总线上的"inPacket"通告，在接收到该通告后将通告中的包添加到自身的漏桶对象（LeakBucket）之中，漏桶对象实现了漏桶算法，以特定的速率向漏桶出口发送数据，包从漏桶中弹出后再进入转发策略处理的下一阶段。本单元中漏桶对象的漏出速率就是该节点处理包的速率。例如，一个节点转发策略单元中漏桶的速率为0.1（单位：个包每时间片）。则在漏桶缓存为空时，该包需要经过1/0.1=10个时间片才能从漏桶中漏出。如果漏桶中以及有缓存内容，再向漏桶中添加包时，包将在漏桶缓冲区中进行排队，漏桶缓冲区的大小由转发信息单元的速率（rate）参数进行设置，支持模拟过程中的动态变化。其次，本单元还实现了包的类型筛选，接收到的包依照包中携带的类型域值，分别调用不同的处理方法。第三，本单元还实现了基本的转发策略算法。如果接收到兴趣包，则调用ForwardUnit.inInterest方法，参数为接口标识和兴趣包；同理，接收到数据包则调用ForwardUnit.inData方法，参数为接口标识和数据包。在ForwardUnit.inInterest方法中，基本的转发策略单元将会调用名为"CS.match"的API，在内容缓存中查找对应的数据包。如果找到对应数据包，触发ForwardUnit.hitEvent方法，调用名"Info.getPendIds"的API，在转发信息单元中获取等待兴趣接口标识集合，并向所有这些接口回应该数据包；如果没有找到对应的数据包，触发ForwardUnit.missEvent方法，内置了洪泛转发兴趣包的策略，向所有其他接口转发该兴趣包。在ForwardUnit.inData方法中，基本的转发策略单元将同ForwardUnit.hitEvent一样向所有的等待兴趣接口回应该数据包，同时还调用名为"CS.store"的API向内容缓存中缓存该数据包。（图，基本转发策略流程图）
用户可以通过扩展该部分来实现所需转发策略，特别是进行新转发策略开发时，本单元将用户改写的最主要模块，例如用户可以通过重写ForwardUnit.missEvent方法实现自己的未命中兴趣包路由策略，例如要实现随机转发策略，只需在该方法中将向所有可发送接口转发兴趣包改为向一个随机接口转发兴趣包即可。为了实现更为负责的转发策略，用户可能需要在此模块中添加更多的信息表和设置更多的逻辑判断，在此模拟器内置洪泛就可使得模拟器能得以适应小规模网络的转发工作，稍大规模的网络使用者可以利用其之类GuidedForwardUnit实现，具体请参考代码例程。

节点除了以上单元外，可能还会包含位置（pos）属性，位置属性用于记录节点所处的地理位置，此属性可能会在模拟节点移动的模块中被使用。此外还包含节点类型（node_type）属性，此属性主要帮助图形界面确定节点的图标。使用者也可以根据需求添加所需属性。







模拟信道的设计与实现
物联网连接方式众多，信道种类也多种多样。为了简化模拟器实现，在此处将信道定义为接口和接口间的连接通道，即接入和接出接口。信道抽象为三个主要属性，传输速率、延迟大小、丢包率。通过对这三个属性的配置来模拟不同种类的信道，如对于以光纤作物理连接的信道，通常具有低延迟、高速率、低丢包率的特点；而对于如蓝牙和无线局域网作连接的信道，通常具有高延迟、低速率、高丢包率的特点。注意，网络速率、延迟大小、丢包率受到环境、下层通信协议、使用具体硬件参数等多种因素的影响，但对以上三个属性的不同配置基本能体现不同连接方式信道的特点。如果一个节点能与另一个节点在不经过其他以信息为中心物联网节点的情况下能直接通信，则这两个节点间将会建立一条信道，每个节点中都会保有一个以对方节点标识命名的接口对象，作为信道的两端。一条信道是单向传输的，如果两个节点能相互通信，则在两节点间将存在两条方向不同的信道，且两条信道的属性可以被分别设置，如手机的上行速率较低，则手机通向路由器的信道速率较小，而手机下行速率可能较大，则同一路由器通向同一手机的信道速率可能较小。以下将分别介绍模拟器对信道三个属性模拟的设计与实现方式。
1、模拟信道的速率
信道速率（rate）是指信道发送一个包的速率，例如一个信道速率为100（单位：size/step），则发送size为1000的包将花费1000/100=10个时间片。信道速率模拟的实现是采用漏桶对象，漏桶对象实现了漏桶算法，以特定的速率向漏桶出口发送数据，漏桶的漏出速率即是模拟信道的速率。漏桶的容量就是发送缓冲区去的大小，缓冲区大小默认为无穷大，即不会因为发送大量数据而丢失数据，只会增大等待时间，使用者可以根据需要手动修改这一设定。包在发送时信道会以包为参数发布"send"通告，发送完成后进入传输过程。
2、模拟信道的延迟
信道延迟（delay）是指数据在信道中传送所需要的时间片长度，所以一个包从发送到目标收到该包的时间应该是该包的发送延迟加上信道的传输延迟。信道在传输过程开始时，会以包为参数发布"transfer"通告，之后以信道延迟启动一个定时器，在定时器满时启动包到达流程。信道延迟是一个整形变量，可以在模拟过程中动态修改，但是已经启动传输的包，不会因为在传输过程中信道延迟的增大或减小而改变到达时间，这种设计主要是为了减小信道的实现复杂度。
3、模拟信道丢包率
信道丢包率（loss）是指一个包在信道传输过程中丢失，最后没有到达目标节点的概率。在网络中，可能会产生丢包的原因很多，有可能是设备损坏或下层网络拥塞等原因，在此将所有可能产生丢包的因素综合，统一用丢包率来衡量。丢包率是一个0到1之间的浮点数，可以取到0或1。数据包的丢失只会发生在包到达流程中，包到达时信道将产生一个0到1之间的随机数，如果该随机数比信道丢包率小，则将此包丢弃并以该包为参数发布"loss"通告；如果该随机数大于信道丢包率，信道将以该包为参数发布"arrive"通告，并将该包交由目标接口处理。



网络拓扑的搭建
节点和信道只是构成模拟器网络的基本元素，模拟器还需要提供让用户利用节点和信道搭建网络的类，这个类被称为模拟器类（Simulator），模拟器管理着网络的拓补结构以及每个节点和信道的标识。模拟器类中节点的标识都是唯一的，一旦一个标识被添加到模拟器中后，再尝试以此标识创建节点将跑出程序错误。模拟器类中的信道标识依照信道源节点标识与信道目的节点标识的组合命名，因此信道标识也具有唯一性。
调用模拟器类的createGraph方法，可以依照一个拓扑结构构建出一个模拟网络，其参数为拓扑图（graph）、节点工厂（nodeFactor）、信道工厂（channelFactor）。拓扑图数据结构为字典，字典键为要创建的节点标识，值为该节点所连接的目标节点标识集合，模拟器将根据节点工厂和信道工厂自动创建节点类和信道类。特别的，如果已经描述了A节点与B节点有所连接，则模拟器类默认在网络中A与B之间建立双向信道。
因调用一次createGraph方法只能向网络中添加一种类型的节点，在实验中可以通过多次调用来实现异构网络的搭建。例如，一个网络中有三类节点：服务器节点、路由节点、客户端节点。这三类节点都搭载了以信息为中心网络协议，不同之处在于所挂载的单元有所不同，实验假设服务器单元不会产生兴趣包请求，可能挂载着特殊的应用层单元类；客户端节点模拟的是传感器节点，可能没有挂载内容缓存单元和替换信息单元；路由节点也可能挂载着特别的转发策略单元，因此在构建这个异构的网络时，可以先创建路由网络，再附加上服务器网络，再附加上客户端网络。具体实现方式如下图（图，创建网络图）
模拟器类中使用networkx库的DiGraph对象来管理网络信息，因此也建议使用者利用networkx库来创建网络拓扑结构。（图，利用networkx创建网络拓扑）
模拟器类除了管理网络拓扑结构的功能外，还提供模拟器的信息总线，因此模拟器类是模拟器的核心，其他的组件将通过挂载在模拟器类上来实现对模拟器类功能的扩展。模拟器类自身会在总线上发布的通告如下："addICNNode"，在节点被添加到模拟器中时发布，参数是节点标识；"addICNEdge"，在信道被添加到模拟器中时发布。模拟器类也提供了一些API使得其他模块能获得网络中的节点对象或信道对象。








模拟器基本模块的设计与实现
模拟器的核心主要负责以信息为中心网络仿真的实现，模拟器的其他模块则用于对实验过程进行监听、控制、记录、展现、交互等功能。这些模块按照实验需求被挂载到模拟器的核心上，相互之间通过模拟器核心总线进行通讯。使用者也可以依据这些模块的实验来开发自己的模块。

2.2.1 信息分发模块
信息分发模块（HubModule）能使得其他模块监听模拟器中节点或信道的通告，还能在节点中注册模块提供的API。这里要注意，节点或信道中的通告作用范围平时仅限于节点内部，一个节点或信道的通告不会被其他节点或信道监听，但模拟器的常常要能监听节点和信道的通告才能实现一些基本功能，所以信息分发模块给模拟器提供一个监听每个节点或信道通告的机制。信息分发模块通过调用HubModule.loadNodeAnnounce方法，可以在全网所有节点的通告中添加一个监听回调函数，但任何一个节点发布该通告时，都会将通告的绑定上该节点标识来调用该回调函数。同理，HubModule.loadEdgeAnnounce用于在全网信道中添加回调函数。例如，节点在缓存一个数据包时会发布"csStore"通告，该通告会由节点内部的缓存替换单元监听和处理。但通过信息分发模块将一个回调函数加载到网络中后，所有节点缓存一个数据包时都会调用该回调函数，该模块就可对全网数据缓存情况进行追踪。

2.2.2 日志模块
日志模块（LogModule）用于监听模拟器核心发布的通告，并将通告转化为日志填写到日志表中。基本的日志模块记录了模拟器节点的四种通告："inPacket"、"outPacket"、"csStore"、"csEvict"，监听这四个通告基本可以描述出包在网络中的转发与缓存情况。例如对A节点向发送B节点发送一个包，计算A节点"outPacket"通告与B节点"inPacket"通告时间差，即可得到该包的发送加传输延迟；如果只有A节点的"outPacket"通告而没B节点的"inPacket"通告，说明包在A到B的信道上传送丢失；监听到一个兴趣包进入节点通告"inPacket"，可以依据相应产生的"outPacket"通告判断该包在节点中的命中与转发情况；同理监听数据包进入节点通告"inPacket"可以依据是否同时产生了缓存通告"csStore"以判断该数据包是否有效等等。日志模块储存信息结构为数据表（DataBaseTable），该表利用超轻量级数据库（PyDBLite）实现，提供条件查询功能。模拟器日志模块数据表有以下字段：
1、索引值（index），索引值为一个单项增加的整形变量，每插入一条新日志记录，则分配一个新索引值且不会重复；
2、日志时间（time），该域用于记录日志的产生时间，该域可能重复，同一模拟器时间片产生的日志记录用于同样的日志时间；
3、节点标识（node_id），用于记录发布通告的节点标识；
4、动作类型（action），为"in"、"out"、"store"、"evict"四个字符串之一，分别对应"inPacket"、"outPacket"、"csStore"、"csEvict"通告信息；
5、接口标识（face_id），对于"inPacket"、"outPacket"日志而言，接口标识表示包到来或发送出去的接口位置，对于"csStore"、"csEvict"日志而言，接口标识域为空（None）；
6、名字域（name），节点操作的包名字；
7、包类型（packet_type），节点操作的包类型；
8、尺寸（size），节点操作的包尺寸；
9、随机域（nonce），节点操作的包随机域；
（图日志表）
在设计中，模拟器并没有采用调用日志函数的方式向文件或流中写入字符串形式的日志，而采用监听总线通告的方式将信息进行结构化处理并记录到数据库中。这样做的优点是不用代码逻辑部分就可为模拟器添加日志功能，缺点在于可记录日志的项有节点总线中发布的通告类型决定，节点有时为了记录某种日志而添加相应的通告。


2.2.3 图形化界面模块
图形化界面模块（GUIModule）能为模拟器提供一个图形化的界面，图形化界面能更直观的向用户展示模拟实验网络的工作情况，还能为用户提供交互功能，使得用户能在图形界面中修改模拟器中节点或信道的属性值。图形化界面不善于处理大规模、长时间的网络仿真实验，更善于在调试转发策略时或展示实验效果时开启。图形化界面模块的基本结构为主窗口类加上挂载插件（Plugin）实现，以下将分别介绍主窗口类以及现有图形化插件。
1、主窗口类
主窗口类（MainWindow）提供了场景对象（NetScene），用于创建、管理、容纳、展现节点物件（NodeWidget）和信道物件（EdgeWidget）。场景对象监听模拟器核心发布的的"addICNNode"通告和"addICNEdge"通告，此通告引起场景对象创建相应的节点物件和信道物件，并将这些物件展现在场景中，场景对象还能对节点和信道点击拖拽移动等事件进行监听，并以通告形式发布到总线，使得其他插件能利用这些通告实现相应功能。
2、画笔插件
画笔插件（PainterPlugin）用于管理画笔类，每播放帧结束后，调用画笔对场景中的节点物件和信道物件进行渲染。不同的画笔对象能使得图形化界面中展现网络的不同信息和状态。画笔插件将会在主窗口上方添加画笔选择组合按钮，提供渲染效果选择功能。
a、网络性能情况画笔（PropertyPainter）用于将网络中各个节点的性能以图形化的方式展现在界面上。网络性能画笔需要能获取节点内容缓存大小、节点包处理速率、节点类型、信道速率、信道延迟、信道丢包率、信道类型这些属性。模拟器性能展现方案如下：一个节点的内容缓存越大，在界面中节点的直径也会越大；节点类型为"server"、"router"、"client"三个值的图标不同；信道速率越大，表示信道的边越宽；随着信道延迟增大，表示信道的边颜色由绿色转向红色；随着信道丢包率增大，表示信道的边可见度（Alpha）有1过渡到0；信道类型的值为"wired"、"wireless"的图标不同。（图）
b、名字缓存情况画笔（NameStorePainter）用于展现指定名字对应的请求等待节点和内容缓存节点在网络中的分布情况。假设当前指定名字为"bupt/mp4"，当前展现方案如下：如果一个节点缓存有指定名字的数据包，即名为"bupt/mp4"的数据包，则该节点为红色；否则如果一个节点缓存有以指定名字为前缀的数据包，如"bupt/mp4/part1"，节点为粉红色，这意味着该节点则该储存着指定名字对应内容的子集；如果一个节点等待兴趣表中有指定名字，如等待着"bupt/mp4"，则该节点为绿色；否则如果该节点等待兴趣表中有指定名字的前缀，如"bupt"，则该节点为粉绿色，这意味着该节点等待着指定名字对应内容的子集；如果一个信道传输着指定名字的兴趣包，表示该信道的边为绿色；如果一个信道传输着指定名字的数据包，表示该信道的边为红色。（图）
c、命中率情况画笔（HitRatioPainter）用于展现节点命中率，节点命中率被定义为查询节点缓存的命中次数与查询总次数之比，值在0到1之间。随着节点的命中率增加节点的颜色由绿色变为红色，没有缓存查询记录的节点命中率设为0。
d、占用率情况画笔（OccupyPainter）用于展示网络节点和信道性能占用率。节点占用率定义为节点已处理数据包的数量与能处理数据包数量之比，值在0到1之间，随着占用率的上升，节点的颜色由绿色变为红色。信道占用率定义为信道已传输数据尺寸与能传输数据尺寸之比，值在0到1之间，随着占用率的上升，信道的颜色由绿色变为红色。
3、播放控制插件
播放控制插件（PlayerPlugin）用于在图形界面中提供一个时间片推进控制组件，包含单步推进和自动播放两个功能。通过修改步进距离值，可以设置每次点击推进的时间片数量。播放控制插件向总线中发布"playSteps"通告，其他插件依此通告作为刷新内容的信号。
4、会话窗口插件
会话窗口插件（InfoDialogPlugin）用于提供节点和信道详情展示框的管理，会话窗口插件监听节点或信道的鼠标双击通告，在一个节点或信道被双击后，生成并打开一个详情会话窗口用于展示和修改该节点或信道的属性值。
a、节点详情窗口（NodeDialog）用于提供节点信息展示和交互，采用模型――控制器――视图（MCV）模式，利用节点控制器（NodeController）将模拟器节点与界面属性进行绑定。在节点窗口中修改的属性会立即作用于模拟器节点的属性值，在图形界面中渲染效果会在窗口被关闭时生效。（图节点窗口展示图）
b、信道详情窗口（EdgeDialog）用于提供信道信息展示和交互，采用模型――控制器――视图（MCV）模式，利用信道控制器（EdgeController）将模拟器信道与界面属性进行绑定。在信道窗口中修改的属性会立即作用于模拟器信道的属性值，在图形界面中渲染效果会在窗口被关闭时生效。（图信道窗口展示图）
5、名字树展示插件
名字树展示插件（NameInfoPlugin）用于展示模拟工程总产生的所有名字。所有名字以树的方式进行展示，并附加显示名字多对应的内容缓存节点数量、等待兴趣节点数量、传输中的兴趣包数量、传输中的数据包数量。通过点选名字树中的项，可以设置模拟器的“选中名字”，“选中名字”可以用于在画笔插件中指定要绘制的名字内容。（图名字树）
6、日志插件
日志插件（LogPlugin）用于显示在模拟器过程中发生的事件，信息记录插件依赖于日志模块。日志插件在界面上提供了一个列表以展示日志项，日志插件有通过用户点击刷新按钮手动进行内容刷新和监听"playSteps"通告而自动刷新两种工作方式，使用者可以通过设置“实时刷新”选项按钮进行配置。日志插件提供了一个对日志条目进行筛选显示的机制，用户需要在文本栏中输入查询语句以筛选过滤信息，语句设计如下：
1>用域名代表域，具体域的类型请参考日志模块中域类型。例如要对日志发生时间域进行筛选，则域名为"time"；
3>利用"="符号进行查询域值的定值筛选，如要查询第100个时间片产生的日志，查询语句为"time=100"；
3>可以利用"<="或"<"符号构成表达式，例如查询实验开始第1000时刻及之后产生的日志记录，查询语句为"1000<=time"；查询当前时间之前100个时间片内产生的日志记录，查询语句为" T-100 < time < T "；
4>利用"in"表达式对进行查询域值的范围值筛选，例如查询节点'A'、'B'产生的日志记录，查询语句为"node_id in ('A','B')"；
5>多重条件语句可采用逗号","相连接，其逻辑关系为与，例如查询节点'A'产生的所有缓存事件日志记录，查询语句为"node_id='A', action='store'"；
查询语句中可插入空格字符，查询成功界面显示"Done"，语法错误导致的查询失败界面显示"Parser Failed"。
7、布局插件
布局插件（LayoutPlugin）用于布局节点物件在场景中的摆放位置，由两种实现模式。第一种为基于节点位置的布局，在此模式下，布局插件需要获取模拟器节点的位置信息，并将场景中的节点放置到相应位置，但节点位置移动时，场景中的节点物件位置也会相应发生变化。第二种是基于网络拓扑结构的布局，模拟器采用Fruchterman-Reingold布局算法，且由交互节点反复发布重新布局指令，直到产生用户满意的布局为止。布局插件在图形界面中提供两个按钮使得使用者能在两种模式下切换场景展示。

2.2.4  数据库模块
数据库模块（DBModule）用于记录实验数据，与日志模块不同，数据库模块主要用于实验结果的收集而非辅助调试使用。数据库模块内部采用数据库表储存数据，模块仍然采用监听节点或信道总线中发布的通告获取数据。


2.2.5  数据统计模块
数据统计模块（StatisticsModule）用于处理数据库模块收集的实验数据，此模块因实验不同差异较大，该模块设计功能主要来源于在开发中验证模拟器运行正确性。同时也向使用者演示如何实现一个自己的数据统计模块。当前数据统计模块有两个功能，对不同名字下数据与时间的比较以及对不同节点数据与时间的比较。
1、对于名字数据的统计资料有助于使用者对不同名字下转发策略或缓存策略的进行性能进行比较。对于名字数据统计有该名字信息请求发起数量与时间的关系、网络中传输该名字信息信道数量与时间的关系、缓存该名字信息的节点数量与时间的关系、网络中该名字的命中率与时间的关系四个维度。例如要进行洪泛转发策略与随机转发策略的特点比较与研究，设计实验：以同样的分布和频率在同一个网络中分别请求两种不同名字的信息，如"A"与"B"；而对于以"A"为前缀的兴趣包采用随机转发的策略，对于以"B"为前缀的兴趣包采用洪泛转发的策略；通过比较网络中两个同一时间下转发信道数量可见"A"名字转发量较小，则随机转发策略占用信道资源更小；通过比较网络中同一时间下两个名字的缓存节点数量可见"B"名字缓存数量更高，则洪泛转发策略能更快的使信息分布到网络中；通过比较网络中同一时间下两个名字的命中率可见"A"名字的命中率更高，则采用随机转发策略能使得网络缓存利用率更高。
（图名字数据比较图）
2、对于节点数据的统计有助于使用者对不同节点资源利用请款进行比较。对于节点数据统计有节点接收包数量与时间的关系、节点发送包数量与时间的关系、节点替换包数量与时间的关系、节点命中率与时间的关系四个维度。例如要研究网络边缘节点与中心节点使用情况的研究，设计实验：在一个9*9的网格网络中，数据放置在在网络中心节点（4，4）；由边缘节点（0，0）、（0，8）、（8，0）、（8，8）个角向网络请求数据；通过最后比较中心节点与边缘节点数据接收包数量可见，同一时间下中心节点接收包数量以及发送包的数量均小于边缘节点，则以信息为中心物联网是能减轻数据源节点的访问次数的；通过比较同一时间下中心节点与边缘节点包替换数量可见中心节点包替换频率小于边缘节点，这是由于中心节点访问频次降低造成，则以信息为中心物联网能降低中心节点替换频率进而减小数据源节点性能颠簸抖动可能性；至于中心节点的命中率与边缘节点的命中率情况，由因节点驱逐替换策略而不同，无可比性。
以上两个功能可使用与大部分研究新型策略的实验，但并不能覆盖所有实验情景，请使用者依照需求实现模块新特性。
（图节点数据比较图）


模拟器使用与效果展示
4.1 模拟器的使用


模拟器采用Python3.6版本语言实现，以下出现代码均为Python3.6脚本代码。

4.1.1 模拟器配置
在进行实验前，构造模拟器对象，并对模拟器添加图形化模块和日志模块，代码如下：

from module import *
sim = Simulator()
sim.install('hub', HubModule())
sim.install('name_monitor', NameMonitor())  # 辅助GUIModule的名字追踪模块
sim.install('node_monitor', NodeMonitor())  # 辅助GUIModule的节点追踪模块
sim.install('edge_monitor', EdgeMonitor())  # 辅助GUIModule的信道追踪模块
sim.install('gui', GUIModule())
sim.install('log', LogModule())

4.1.2 模拟器网络搭建
启动模拟器，需要在脚本中搭建出模拟器网络。搭建网络过程包括构建所需的节点和信道、以下将演示构建一个由3种类型6个节点组成的小型网络过程。其中客户端节点与路由器以无线信道相连接，服务器与路由器之间以有线信道相连接

首先实现一个节点工厂同于产生网络中路由器节点，其类型"server"，内容缓存大小为10000，替换策略为"FIFO"，循环兴趣包检查表条目保存时间为10000个时间片，转发包处理速率为1个包/时间片，转发缓存最大值为正无穷，再依照此实现两种以信息为中心物联网节点，类型分别为"router"、"client"，不同之处在于"router"类型节点内容缓存大小为1000，转发包处理速率为0.1包/时间片；"client"类型节点无内容缓存，转发包处理速率为0.1包/时间片，代码如下：

from core import INF
from unit.node import nodeFactory
ServerNodeFactor = nodeFactory(
    node_type = "server", cs_capacity= 10000, 
    replace_mode="FIFO", nonce_life_time= 10000, 
    forward_rate= 1, forward_capacity= INF)

RouterNodeFactor = nodeFactory(
    node_type = "router", cs_capacity= 1000,
    replace_mode="FIFO", nonce_life_time= 10000,
    forward_rate= 0.1, forward_capacity= INF)

ClientNodeFactor = nodeFactory(
    node_type = "client", nonce_life_time= 10000,
    forward_rate= 0.1, forward_capacity= INF)

接下来，构建两种信道的工厂类，类型分别为"wired"、"wireless"，"wired"信道发送速率为1000，延迟为1，丢包率0；"wireless"信道发送速率较"wired"低为1000，延迟为10，丢包率为0.1，代码如下：

WiredChannel= channelFactor(channel_type='wired', rate= 1000, delay=1, loss=0)
WirelessChannel= channelFactor(channel_type='wireless', rate= 100, delay=10, loss=0.1)

最后利用节点与信道工厂类可以构建网络图。
构建网络图首先构建两个相连的路由器节点'r1'与'r2'，用有线信道相连接。参数中只需要描述'r1'的邻居有'r2'节点即可，模拟器会自动构建两个节点和双向的信道。为节点'r1'添加两个服务器节点's1'与's2'，用有线信道相连，在路由器节点'r2'添加两个客户端节点'c1'与'c2'，用无线信道相连，代码如下：

sim.createGraph({'r1':['r2']}, RouterNodeFactor, WiredChannel)
sim.createGraph({'r1':['s1', 's2']}, ServerNodeFactor, WiredChannel)
sim.createGraph({'r2':['c1', 'c2']}, ClientNodeFactor, WirelessChannel)

网络效果如图


4.1.3 网络信息的添加与请求
使用网络进行仿真实验，需要在网络中添加数据包以及发起兴趣包，以下来将利用上一网络进行网络信息添加与请求演示。构造连个兴趣包对象，两个数据包对象，并在服务器's1'中存入数据包'A'，服务器's2'中存入数据包'B'；构造两个循环对象，使得客户端节点'c1'以每10时间片一个周期的频率发起对信息'A'的请求，客户端节点'c2'以每20时间片一个周期的频率发起对信息'B'的请求。代码如下

# 构造4个信息包
interest_a= Packet(Name('A'), Packet.INTEREST, 1)
data_a= Packet(Name('A'), Packet.DATA, 100)
interest_b= Packet(Name('B'), Packet.INTEREST, 1)
data_b= Packet(Name('B'), Packet.DATA, 100)

def askPacket(node_id, packet):
    sim.node(node_id).ask( packet.fission() )  # packet.fission()以生成一个随机域不同的包
sim.node('s1').store(data_a)  # 在服务器's1'中存入数据包'A'
sim.node('s2').store(data_b)  # 在服务器's2'中存入数据包'B'

Loop(askPacket, 'c1', interest_a, delta= 10)  # 'c1'以10为周期发出兴趣包'A'
Loop(askPacket, 'c2', interest_b, delta= 20)  # 'c2'以20为周期发出兴趣包'B'

sim.showGUI()  # 启动模拟器

4.1.4  控制与查看模拟过程

通过播放按钮可以启动模拟过程，也可通过单步按钮手动推进模拟过程进行。模拟信息查看分为几个部分：
节点性能图显示概要显示节点性能参数
数据缓存图显示相应数据缓存位置
命中率图显示节点命中率
占用率图显示节点资源占用率

4.2  模拟器参与的实验
在模拟器设计与实现过程中，参与了关于信息在网络中传播情况的实验研究，参与发表论文《Content Diffusion Model of Information-Centric Networking》。实验要求在网格网络（grid）、无标度网络（scale-free）两种的网络拓扑结构上进行模拟实验；网络起始只有一个节点内缓存有目标内容，网络中其他节点在模拟过程中产生对该数据的请求，发起请求的节点数量分别服从均匀分布与泊松分布两种情况，平均请求数量为p；为了模拟一个繁忙的网络情况，实验中的节点将会对缓存的数据进行自动的替换，包括FIFO替换策略与LRU替换策略，内容缓存被替换时间设为lambda，在FIFO策略下第t时刻缓存的数据一定在第t+lambda时刻被替换，在LRU策略与最后一次访问时间有关而与插入时间无关，即在t时刻缓存最后一次被访问则将在第t+lambda时刻被替换；最后实验要得到节点中缓存内容数量与时间的关系、转发包数量与时间的关系，请求节点与最近数据源距离（跳数）与时间的关系。实验证明关于传播模型建立的理论模型与实验结果匹配，证明了传播模型的正确性。



本模拟器完全Python3.6语言实现，采用解释器为CPython解释器，图形界面利用PyQt5实现，数据库使用PyDBLite,依赖的库有networkx、numpy、pandas、PyQt5、PyDBLite。由于解释器本身限制及全局时钟变量的使用，一个模拟实验只能占用一个线程，如使用者需要加速模拟实验的进行，只能利用多进程同时进行多个参数不同的模拟实验运行。
模拟器主要占用计算机CPU资源与内存资源，在开启数据库情况下还会占用外存资源，因此计算机硬件性能会影响到模拟器运行效率。由于模拟器配置有多个模块，模拟器挂载模块数量与复杂度也会直接影响模拟实验运行性能，如是否启用图形界面，是否启用数据库，是否开启数据库的持久化层都会造成模拟器性能不同。所以以下对性能的分析都是在相同硬件下进行，并将对挂载不同模块情况进行比较。
因为对同一时长的模拟也可能由于请求事件密度、转发策略不同、替换策略不同而对性能影响不同，所以不能简答将模拟时间与真实运行时间比值作为性能分析的指标。因为同样规模的节点和信道数量也可能由于网络拓扑结构、网络参数不同造成实验耗时不同，所以也不能以节点数量与真实运行时间比值作为性能分析的指标。模拟器采用的是离散事件模拟技术，每一个实验中事件复杂度相似，且无论模拟网络规模多大还是转发策略多复杂，追踪都转化为事件进行处理，因此可以采用模拟器处理事件数量与真实运行时间比值作为性能分析的指标。
以下为不同模块下性能比较数据



6.1  工作总结
伴随着对以信息为中心网络研究的深入与物联网的发展，会产生越来越多此方面的实验需求。同时也由于对以信息为中心物联网应用的推广，能进行研究和实验的点也越来越多。现有的网络模拟器所适应的网络技术相对成熟，但对于下一代互联网协议支持还不够好，因此产生了对新型网络协议的仿真软件的需求。因此本文针对以信息为中心物联网的特点，参考国内外相关研究内容的特点，服务于实验室相关方向实验的需求，尝试开发有针对性、高扩展性、用户友好的模拟器软件，给相关实验的实现提供了便利。
本位主要针对模拟器在节点数量较多的情况下进行设计，经过对现有相关实验内容分析与传统模拟器所不适应的问题，简化了网络下层协议的仿真，并将网络层转发操作封装为编程接口提供给实验者实验，并加入了常用的图形化模块、日志模块、数据库模块等，使得模拟器有更高用户友好性。其中如何将连续的网络转发过程转化为离散事件的问题比较关键，本文将网络转发过程的导致状态变化的行为抽象为事件，利用离散事件模拟技术进行仿真以实现这一需求。
本文还详细阐述了模拟器核心和各个模块的设计思想与实现方式，包括模块的结构和数据交流方式，并分析了现有实现方法的优点与缺点。

6.2  工作展望
由于以信息为中心物联网还在不断发展中，虽然本文实现了一个功能较全、涵盖大多数此方向实验需求的模拟器，但从模拟器的性能、稳定性、展示效果等方面还有很多可以改进的地方：首先，在性能方面，为了模拟器软件功能的快速实现以及能适应易变的实验需求，模拟器采用了动态类型的脚本语言（Python3.6），但是脚本语言执行效率较低会导致模拟实验时间较长，因此性能方面有很大优化空间；其次，在图形界面方面，模拟器使用客户端界面库（Qt），今后可以将模拟器移植到服务端并利用网页界面库重新实现图形化模块；此外，模拟器内置的节点类型、信道类型、转发策略算法、缓存算法较少，今后可以为用户提供更多内置类型与算法，以便使用者能更快的搭建实验所需平台。






